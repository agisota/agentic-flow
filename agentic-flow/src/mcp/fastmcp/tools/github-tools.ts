import { z } from 'zod';
import { GitHubService } from '../../../services/github-service.js';

export function registerGitHubTools(server: any): void {
  // Tool: github_pr_create
  server.addTool({
    name: 'github_pr_create',
    description: 'Create a new pull request on the current repository',
    parameters: z.object({
      title: z.string().min(1).describe('PR title'),
      body: z.string().describe('PR description/body'),
      base: z.string().optional().describe('Base branch (defaults to default branch)'),
      head: z.string().optional().describe('Head branch (defaults to current branch)'),
    }),
    execute: async ({ title, body, base, head }: { title: string; body: string; base?: string; head?: string }) => {
      try {
        const svc = GitHubService.getInstance();
        const pr = svc.createPR({ title, body, base, head });
        return JSON.stringify({ success: true, data: pr, timestamp: new Date().toISOString() }, null, 2);
      } catch (error: any) {
        return JSON.stringify({ success: false, error: error.message, timestamp: new Date().toISOString() }, null, 2);
      }
    }
  });

  // Tool: github_pr_list
  server.addTool({
    name: 'github_pr_list',
    description: 'List pull requests on the current repository',
    parameters: z.object({
      state: z.enum(['open', 'closed', 'merged', 'all']).optional().default('open').describe('PR state filter'),
      limit: z.number().positive().optional().default(10).describe('Maximum PRs to return'),
    }),
    execute: async ({ state, limit }: { state: string; limit: number }) => {
      try {
        const svc = GitHubService.getInstance();
        const prs = svc.listPRs({ state, limit });
        return JSON.stringify({ success: true, data: { prs, count: prs.length }, timestamp: new Date().toISOString() }, null, 2);
      } catch (error: any) {
        return JSON.stringify({ success: false, error: error.message, timestamp: new Date().toISOString() }, null, 2);
      }
    }
  });

  // Tool: github_pr_review
  server.addTool({
    name: 'github_pr_review',
    description: 'Add a review comment to a pull request',
    parameters: z.object({
      number: z.number().positive().describe('PR number'),
      body: z.string().min(1).describe('Review comment body'),
      event: z.enum(['approve', 'request-changes', 'comment']).optional().default('comment').describe('Review event type'),
    }),
    execute: async ({ number, body, event }: { number: number; body: string; event: string }) => {
      try {
        const svc = GitHubService.getInstance();
        const result = svc.reviewPR({ number, body, event });
        return JSON.stringify({ success: true, data: result, timestamp: new Date().toISOString() }, null, 2);
      } catch (error: any) {
        return JSON.stringify({ success: false, error: error.message, timestamp: new Date().toISOString() }, null, 2);
      }
    }
  });

  // Tool: github_pr_merge
  server.addTool({
    name: 'github_pr_merge',
    description: 'Merge a pull request by number',
    parameters: z.object({
      number: z.number().positive().describe('PR number to merge'),
      method: z.enum(['merge', 'squash', 'rebase']).optional().default('merge').describe('Merge method'),
    }),
    execute: async ({ number, method }: { number: number; method: string }) => {
      try {
        const svc = GitHubService.getInstance();
        const result = svc.mergePR({ number, method });
        return JSON.stringify({ success: true, data: result, timestamp: new Date().toISOString() }, null, 2);
      } catch (error: any) {
        return JSON.stringify({ success: false, error: error.message, timestamp: new Date().toISOString() }, null, 2);
      }
    }
  });

  // Tool: github_issue_create
  server.addTool({
    name: 'github_issue_create',
    description: 'Create a new GitHub issue',
    parameters: z.object({
      title: z.string().min(1).describe('Issue title'),
      body: z.string().describe('Issue body/description'),
      labels: z.array(z.string()).optional().describe('Labels to add'),
    }),
    execute: async ({ title, body, labels }: { title: string; body: string; labels?: string[] }) => {
      try {
        const svc = GitHubService.getInstance();
        const issue = svc.createIssue({ title, body, labels });
        return JSON.stringify({ success: true, data: issue, timestamp: new Date().toISOString() }, null, 2);
      } catch (error: any) {
        return JSON.stringify({ success: false, error: error.message, timestamp: new Date().toISOString() }, null, 2);
      }
    }
  });

  // Tool: github_issue_list
  server.addTool({
    name: 'github_issue_list',
    description: 'List GitHub issues with optional filters',
    parameters: z.object({
      state: z.enum(['open', 'closed', 'all']).optional().default('open').describe('Issue state filter'),
      labels: z.array(z.string()).optional().describe('Filter by labels'),
      limit: z.number().positive().optional().default(10).describe('Maximum issues to return'),
    }),
    execute: async ({ state, labels, limit }: { state: string; labels?: string[]; limit: number }) => {
      try {
        const svc = GitHubService.getInstance();
        const issues = svc.listIssues({ state, labels, limit });
        return JSON.stringify({ success: true, data: { issues, count: issues.length }, timestamp: new Date().toISOString() }, null, 2);
      } catch (error: any) {
        return JSON.stringify({ success: false, error: error.message, timestamp: new Date().toISOString() }, null, 2);
      }
    }
  });

  // Tool: github_repo_info
  server.addTool({
    name: 'github_repo_info',
    description: 'Get information about the current repository',
    parameters: z.object({}),
    execute: async () => {
      try {
        const svc = GitHubService.getInstance();
        const info = svc.getRepoInfo();
        return JSON.stringify({ success: true, data: info, timestamp: new Date().toISOString() }, null, 2);
      } catch (error: any) {
        return JSON.stringify({ success: false, error: error.message, timestamp: new Date().toISOString() }, null, 2);
      }
    }
  });

  // Tool: github_workflow_status
  server.addTool({
    name: 'github_workflow_status',
    description: 'Check GitHub Actions workflow run status',
    parameters: z.object({
      limit: z.number().positive().optional().default(5).describe('Maximum workflow runs to return'),
    }),
    execute: async ({ limit }: { limit: number }) => {
      try {
        const svc = GitHubService.getInstance();
        const runs = svc.getWorkflowStatus({ limit });
        return JSON.stringify({ success: true, data: { runs, count: runs.length }, timestamp: new Date().toISOString() }, null, 2);
      } catch (error: any) {
        return JSON.stringify({ success: false, error: error.message, timestamp: new Date().toISOString() }, null, 2);
      }
    }
  });
}
